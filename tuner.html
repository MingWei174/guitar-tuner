<!DOCTYPE html>
<html lang="zh-Hant">
<head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>Tuner - loose</title>
<style>
body{font-family:Arial;background:#1e2126;color:#fff;padding:18px}
.controls{display:flex;gap:8px;margin-bottom:12px}
button{padding:8px 12px;border-radius:6px;border:none;cursor:pointer}
.start{background:#4caf50;color:#fff} .stop{background:#ff4d4d;color:#fff} .rec{background:#333;color:#fff}
#gaugeCanvas,#waveCanvas{display:block;background:#222;margin-top:8px}
.info-row{display:flex;justify-content:space-between;width:600px;color:#9aa8bf}
.note{font-size:64px;text-align:center;margin-top:8px}
.cents{font-size:22px;text-align:center;margin-top:6px;color:#4fc3f7}
</style>
</head>
<body>
<div class="controls">
  <button id="startBtn" class="start">▶ 開始調音</button>
  <button id="stopBtn" class="stop" disabled>■ 停止</button>
  <button id="recBtn" class="rec" disabled>REC</button>
</div>
<div class="info-row"><div>A4=440Hz</div><div id="debugInfo">RMS: 0.0000</div></div>
<canvas id="gaugeCanvas" width="600" height="300"></canvas>
<div class="cents" id="cents">0¢</div>
<div class="note" id="note">--</div>
<canvas id="waveCanvas" width="600" height="240"></canvas>
<div id="status" style="color:#9aa8bf;margin-top:8px">請按開始</div>

<script>
/* loose 參數 */
const PARAMS = {
  MIN_FREQ: 40,
  MAX_FREQ: 2000,
  ENERGY_THRESHOLD: 0.0005,
  PITCH_INTERVAL_MS: 60
};
/* 其餘與測試版相同的實作（縮減說明） */
let audioCtx=null, source=null, analyser=null, mediaStream=null, rafId=null;
let mediaRecorder=null, audioChunks=[], isRecording=false;
const RESIZE_ANALYSER_SIZE = 2048;
const STANDARD_TUNING = {"E2":82.41,"A2":110.00,"D3":146.83,"G3":196.00,"B3":246.94,"E4":329.63};
let afArray=null, lastPitchTime=0;

const startBtn=document.getElementById('startBtn');
const stopBtn=document.getElementById('stopBtn');
const recBtn=document.getElementById('recBtn');
const statusEl=document.getElementById('status');
const noteEl=document.getElementById('note');
const centsEl=document.getElementById('cents');
const debugEl=document.getElementById('debugInfo');

const gaugeCanvas=document.getElementById('gaugeCanvas'); const gctx=gaugeCanvas.getContext('2d');
const waveCanvas=document.getElementById('waveCanvas'); const wctx=waveCanvas.getContext('2d');

const offscreen=document.createElement('canvas'); offscreen.width=waveCanvas.width; offscreen.height=waveCanvas.height;
const offCtx=offscreen.getContext('2d');

function closestString(freq){
  let bestName=null,bestF=null,bestDiff=Infinity;
  for(const n in STANDARD_TUNING){const f=STANDARD_TUNING[n];const diff=Math.abs(1200*Math.log2(freq/f)); if(diff<bestDiff){bestName=n;bestF=f;bestDiff=diff;}}
  if(bestDiff>200){const noteNum=12*(Math.log2(freq/440))+69;const noteNames=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];const rounded=Math.round(noteNum);bestName=noteNames[(rounded%12+12)%12];bestF=440*Math.pow(2,(rounded-69)/12);}
  const cents=1200*Math.log2(freq/bestF); return {name:bestName,targetF:bestF,cents:cents};
}

function autocorrWithCheck(buffer,sampleRate){
  const size=buffer.length;
  let mean=0; for(let i=0;i<size;i++) mean+=buffer[i]; mean/=size; for(let i=0;i<size;i++) buffer[i]-=mean;
  let sumSq=0; for(let i=0;i<size;i++) sumSq+=buffer[i]*buffer[i]; let rms=Math.sqrt(sumSq/size);
  if(rms < PARAMS.ENERGY_THRESHOLD) return null;
  let bestOffset=-1,bestCorr=0;
  const minLag=Math.floor(sampleRate/PARAMS.MAX_FREQ);
  const maxLag=Math.floor(sampleRate/PARAMS.MIN_FREQ);
  for(let lag=minLag;lag<=maxLag;lag++){let corr=0; for(let i=0;i<size-lag;i++) corr+=buffer[i]*buffer[i+lag]; if(corr>bestCorr){bestCorr=corr;bestOffset=lag;}}
  if(bestOffset<=0) return null;
  let s0=0,s2=0;
  if(bestOffset-1>0) for(let i=0;i<size-(bestOffset-1);i++) s0+=buffer[i]*buffer[i+bestOffset-1];
  if(bestOffset+1<size) for(let i=0;i<size-(bestOffset+1);i++) s2+=buffer[i]*buffer[i+bestOffset+1];
  const denom=(s0 - 2*bestCorr + s2);
  let offset=bestOffset;
  if(denom!==0) offset = bestOffset + 0.5*(s0 - s2)/denom;
  return sampleRate/offset;
}

/* draw functions (same as earlier) */
function drawGauge(cents){
  const w=gaugeCanvas.width,h=gaugeCanvas.height,cx=w/2,cy=h-20,radius=h-40;
  gctx.clearRect(0,0,w,h);
  gctx.beginPath(); gctx.arc(cx,cy,radius,Math.PI,2*Math.PI); gctx.lineWidth=15; gctx.strokeStyle='#222'; gctx.stroke();
  gctx.save(); gctx.translate(cx,cy);
  const totalTicks=40;
  for(let i=0;i<=totalTicks;i++){ const angle=Math.PI+(Math.PI*i/totalTicks); const cos=Math.cos(angle), sin=Math.sin(angle); const isCenter=i===totalTicks/2; const isMajor=i%5===0; const innerR=radius-(isMajor?20:10); const outerR=radius;
    gctx.beginPath(); gctx.moveTo(cos*innerR,sin*innerR); gctx.lineTo(cos*outerR,sin*outerR);
    if(isCenter) gctx.strokeStyle='#4caf50'; else if(i<10||i>30) gctx.strokeStyle='#d9534f'; else gctx.strokeStyle='#555';
    gctx.lineWidth=isCenter?4:2; gctx.stroke();
  }
  gctx.restore();
  let safeCents=Math.max(-50,Math.min(50,cents)); let angle=Math.PI+(Math.PI*(safeCents+50)/100);
  if(cents===-999) angle=Math.PI*1.5; const ptrLen=radius-10; const ptrX=cx+Math.cos(angle)*ptrLen; const ptrY=cy+Math.sin(angle)*ptrLen;
  gctx.beginPath(); gctx.moveTo(cx,cy); gctx.lineTo(ptrX,ptrY); gctx.lineWidth=5; gctx.strokeStyle=Math.abs(safeCents)<5?'#4caf50':'#ff4d4d'; gctx.lineCap='round'; gctx.stroke();
  gctx.beginPath(); gctx.arc(cx,cy,10,0,2*Math.PI); gctx.fillStyle='#444'; gctx.fill();
}

function drawRollingWave(buffer){
  const w=waveCanvas.width,h=waveCanvas.height,speed=2;
  offCtx.clearRect(0,0,w,h); offCtx.drawImage(waveCanvas,0,0);
  wctx.clearRect(0,0,w,h); wctx.drawImage(offscreen,-speed,0);
  let sum=0; for(let v of buffer) sum+=v*v; let rms=Math.sqrt(sum/buffer.length)*10; if(rms>1) rms=1;
  const barHeight=rms*h, yStart=(h-barHeight)/2;
  wctx.fillStyle = rms>0.05? '#4caf50' : '#111'; wctx.fillRect(w-speed,yStart,speed,barHeight);
}

drawGauge(-999); wctx.fillStyle='#0b0b0b'; wctx.fillRect(0,0,waveCanvas.width,waveCanvas.height);

/* media recorder */
function startRecording(stream){ audioChunks=[]; try{ mediaRecorder=new MediaRecorder(stream);}catch(e){console.warn('no MR',e); statusEl.textContent='無法錄音'; return;} mediaRecorder.ondataavailable=ev=>{ if(ev.data && ev.data.size>0) audioChunks.push(ev.data); }; mediaRecorder.onstop=()=>{ const b=new Blob(audioChunks,{type:'audio/webm'}); const u=URL.createObjectURL(b); const a=document.createElement('audio'); a.controls=true; a.src=u; document.body.appendChild(a); statusEl.textContent='錄音完成';}; mediaRecorder.start(); isRecording=true; recBtn.textContent='REC ●'; statusEl.textContent='錄音中...';}
function stopRecording(){ if(mediaRecorder && isRecording){ mediaRecorder.stop(); isRecording=false; recBtn.textContent='REC'; } }

/* controls */
recBtn.addEventListener('click',()=>{ if(!mediaStream)return; if(!isRecording) startRecording(mediaStream); else stopRecording(); });

startBtn.addEventListener('click', async ()=>{
  startBtn.disabled=true; statusEl.textContent='啟動中...'; console.log('start clicked');
  try{
    mediaStream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,autoGainControl:false,noiseSuppression:false}});
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    source = audioCtx.createMediaStreamSource(mediaStream);
    analyser = audioCtx.createAnalyser(); analyser.fftSize = RESIZE_ANALYSER_SIZE; afArray = new Float32Array(analyser.fftSize);
    source.connect(analyser);
    stopBtn.disabled=false; recBtn.disabled=false; statusEl.textContent='偵測中...'; drawGauge(-999); lastPitchTime=0;
    mediaStream.getTracks().forEach(t=>console.log('track',t.kind,'state',t.readyState,'enabled',t.enabled));
    loop();
  }catch(err){ console.error(err); statusEl.textContent='取得麥克風失敗'; startBtn.disabled=false; }
});

stopBtn.addEventListener('click',()=>{
  if(rafId){ cancelAnimationFrame(rafId); rafId=null; }
  if(isRecording) stopRecording();
  if(audioCtx) { audioCtx.close().catch(()=>{}); audioCtx=null; }
  if(mediaStream) mediaStream.getTracks().forEach(t=>t.stop());
  mediaStream=null; analyser=null; source=null;
  startBtn.disabled=false; stopBtn.disabled=true; recBtn.disabled=true; statusEl.textContent='已停止'; noteEl.textContent='--'; centsEl.textContent='0¢'; drawGauge(-999);
});

function loop(){
  rafId = requestAnimationFrame(loop);
  if(!analyser) return;
  if(audioCtx && audioCtx.state === 'suspended') { audioCtx.resume().catch(e=>console.warn('resume',e)); }
  analyser.getFloatTimeDomainData(afArray);
  let sum=0; for(let i=0;i<afArray.length;i++) sum += afArray[i]*afArray[i]; const rms = Math.sqrt(sum/afArray.length);
  debugEl.textContent = `RMS: ${rms.toFixed(4)}`;
  drawRollingWave(afArray);
  const now = performance.now();
  if(rms > PARAMS.ENERGY_THRESHOLD && (now - lastPitchTime > PARAMS.PITCH_INTERVAL_MS)) {
    lastPitchTime = now;
    const bufCopy = new Float32Array(afArray);
    const freq = autocorrWithCheck(bufCopy, audioCtx.sampleRate);
    console.log('RMS', rms.toFixed(6), 'audioCtx', audioCtx?audioCtx.state:'null', 'freq', freq);
    if(freq && freq > 30 && freq < 4000) {
      const res = closestString(freq);
      noteEl.textContent = res.name;
      centsEl.textContent = (res.cents>=0?'+':'') + Math.round(res.cents) + '¢';
      drawGauge(res.cents);
    } else {
      drawGauge(-999);
    }
  } else {
    if(rms <= PARAMS.ENERGY_THRESHOLD) drawGauge(-999);
  }
}
</script>
</body>
</html>
